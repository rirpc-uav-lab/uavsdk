@startuml

|#LightGrey|T|Tree
|#AntiqueWhite|B|Blackboard

|B|
|T|
start
partition "BLOCK CheckLandedState"{
    |B|
    :Получить landed_state = telem->landed_state;
    |T|
    if (landed_state == OnGround?) then (да)
        #pink:Вернуть FAILED;
        stop
    else (нет)
        #LimeGreen:Вернуть SUCCESS;
    endif
}
stop

start
partition "BLOCK CheckMission"{
    |B|
    :mission_not_empty = Проверить наличие точек в миссии в blackboard;
    |T|
    if (mission_not_empty) then (Да)
        #LimeGreen:Вернуть SUCCESS;
    else (Нет)
        #pink:Вернуть FAILED;
    endif
}
stop

start
partition "BLOCK CheckRTLMission"{
    :BLOCK CheckMission;
    |B|
    :parameters_ready = Проверить наличие необходимых параметров;
    |T|
    if (CheckMission == SUCCESS AND parameters_ready) then (Да)
        #LimeGreen:Вернуть SUCCESS;
    else (Нет)
        #pink:Вернуть FAILED;
    endif
}
stop

start
partition #Red "BLOCK PathFollowingOffboard"{
    :Выполнить полет;
    #LimeGreen:Вернуть SUCCESS;
}

note right
    Детализировать и внедрить варианты управления
end note
stop


start
partition "BLOCK UpdateCurrentTime"{
    |B|
    :ready = Проверить наличие current_time в blackboard;
    |T|

    if (ready) then (да)
        |B|
        :current_time = this->get_clock()->now().seconds() + this->get_clock()->now().nanoseconds() / double(1e9);
        |T|
        #LimeGreen:Вернуть SUCCESS;
    else (нет)
        #red :ИСКЛЮЧЕНИЕ;
    endif
}
stop

start
partition "BLOCK UpdateMarkerVisible"{
    |B|
    :ready = Проверить наличие marker_visible и last_time_marker_was_seen в blackboard;
    |T|

    if (ready) then (да)
        |B|
        |T|
        #LimeGreen:Вернуть SUCCESS;
    else (нет)
        |B|
        :seen = Проверить наличие last_time_marker_was_seen в blackboard;
        if (не seen) then (да)
            ' #red :ИСКЛЮЧЕНИЕ;
            |T|
            #pink:Вернуть FAILED;
            stop
        endif

        |B|
        if (current_time - last_time_marker_was_seen < PLD_MARKER_TIMEOUT_S) then (Да)
            :marker_visible = true;
        else (нет)
            :marker_visible = false;
        endif
        |T|
        #LimeGreen:Вернуть SUCCESS;
    endif
}
stop

start
partition "BLOCK Land"{
    :Завершить режим Offboard;
    :Перейти в режим Land;
    :Сесть;
    ' #pink #LimeGreen:Вернуть SUCCESS;
    #LimeGreen :Вернуть SUCCESS;
}
stop


start
partition "BLOCK LookForMarker"{
    |B|
    :Получить на вход параметры current_time, marker_visible, search_start_time, search_timed_out;
    |T|
    
    :BLOCK UpdateCurrentTime;
    :BLOCK UpdateMarkerVisible;

    if (search_timed_out) then (Да)
        :BLOCK Land;
    else (Нет)
        #red :ИСКАТЬ МАРКЕР;
    endif
}
stop

start
partition "BLOCK SearchMarker"{
    :Записать момент начала поиска;
    :Записать текущее время;
    |B|
    :Создать флаги search_timed_out(false), marker_visible(false);
    |T|
    :Перейти в Offboard;

    while (не search_timed_out) is (Да)
        if (не marker_visible) then (Да)
            :BLOCK LookForMarker;
        else (нет)
            |B|
            :Обновить search_start_time в blackboard;
            |T|
            break
        endif
    endwhile (Нет) 
    
    if (search_timed_out) then (да)
        :BLOCK Land;
        #pink:Вернуть FAILED;
        stop
    endif
    
    #LimeGreen :Вернуть SUCCESS;
}
stop


start
partition "BLOCK RegulatePositionFunc"{
    |B|
    :Получить на вход параметры dr, current_time, last_pid_time, pid из blackboard;
    :Обновить dr в blackboard;
    |T|
    :float alpha = atan2(-y_rad, x_rad);

    :float x_speed = movement_radius * cos(alpha);
    :float y_speed = movement_radius * sin(alpha);

    :float vr = sqrt(x_speed * x_speed + y_speed * y_speed);
    if (vr > PLD_MAX_SPD)) then (Да)
        :x_speed = PLD_MAX_SPD * cos(alpha);
        :y_speed = PLD_MAX_SPD * sin(alpha);
    endif

    |B|
    :Записать в blackboard параметры x_speed, y_speed, alpha;
    |T|
    #LimeGreen:Вернуть SUCCESS;
}
stop

start
partition "BLOCK RegulateHeightFunc"{
    |B|
    :Получить на вход параметры current_time, last_pid_time, pid_z из blackboard;
    :Получить на вход аргументы goal_height, min_speed из blackboard;
    :error = goal_height - telem->current_distance_sensor_data.current_distance_m;
    |T|
    :float z_speed = pid_z.pid(error, current_time - last_pid_time);
    :if (abs(z_speed) > PLD_MAX_ALT_SPD) z_speed = sgn(z_speed) * PLD_MAX_ALT_SPD;
    :if (abs(z_speed) < PLD_MIN_ALT_SPD) z_speed = sgn(z_speed) * PLD_MIN_ALT_SPD;
    :z_speed = -z_speed;
    note right
        Изменение направления скорости для
        работы в системе координат NED
    end note
    |B|
    :Записать z_speed в blackboard;
    |T|
}
stop

start
partition "BLOCK OrientationRegulation"{
    while (marker_visible AND ориентация не выровнена) is (Да)
        |B|
        :Обновить search_start_time;
        :Обновить current_time;
        :BLOCK UpdateMarkerVisible;
        :Обновить search_timed_out;
        :Записать alpha = atan2(-y_rad, x_rad) в blackboard; 
        |T|
        ' :res<vx,vy> = regulate_position_func();
        :BLOCK RegulatePositionFunc();
        ' :z_speed = regulate_height_func(PLD_SRCH_ALT, 0.0);
        :BLOCK RegulateHeightFunc(goal_height=PLD_SRCH_ALT, min_speed=0.0);

        if (ориентация не выровнена) then (Да)
            |B|
            :yaw_speed = 180.0 / M_PI * pid_yaw.pid(alpha_rad, current_time - last_pid_time);
            :Установить скорости x_speed, y_speed, z_speed, -yaw_speed;
            note right
                -yaw_speed по той же причине, 
                что и с высотой - из-за направления
                оси Z в системе координат NED
            end note
            |T|
        else (Нет)
            break
        endif
    endwhile (Нет) 
}
stop

start
partition "BLOCK CheckSearchTimeout"{
    if (search_timed_out) then (Да)
        #Red :BLOCK Land;
        note right
            Сомневаюсь в необходимости
            этого блока
        end note
    endif
}
stop


start 
partition "BLOCK Landing"{
    while (current_landed_state != OnGround) is (Да)
        |B|
        :Обновить current_time;
        |T|
        :BLOCK UpdateMarkerVisible;
        |B|
        :Обновить search_timed_out;
        |T|
        if (marker_visible) then (Да)
            |B|
            :Обновить search_start_time;
            :Записать alpha = atan2(-y_rad, x_rad) в blackboard; 
            |T|
            ' :res<vx,vy> = regulate_position_func();
            :BLOCK RegulatePositionFunc();
            ' :z_speed = regulate_height_func(0.0, PLD_MIN_ALT_SPD);
            :BLOCK RegulateHeightFunc(goal_height=0.0, min_speed=PLD_MIN_ALT_SPD);
            |B|
            :yaw_speed = 180.0 / M_PI * pid_yaw.pid(alpha_rad, current_time - last_pid_time);
            :Установить скорости x_speed, y_speed, z_speed, -yaw_speed;
            |T|
        else (нет)
            :pid's clear();
            if (search_timed_out) then (Да)
                :BLOCK Land;
            endif

            :Определить uav_above_land_guarantee_threshold;
            if (uav_above_land_guarantee_threshold) then (Да)
                :Определить uav_lower_than_search_altitude;
                if (uav_lower_than_search_altitude) then (Да)
                    :Лететь вверх;
                else (Нет)
                    :Лететь вниз;
                endif
                |B|
                :Обновить last_pid_time;
                |T|
            else (Нет)
                :BLOCK Land;
            endif
        endif
    endwhile (Нет) 
}
stop

start
partition "BLOCK CenterAboveMarker"{
    |B|
    :Создать marker_centered = bool(x_rad > (PLD_ACC_RADIUS_DEG * M_PI / 180.0) or y_rad > (PLD_ACC_RADIUS_DEG * M_PI / 180.0)) в blackboard;
    |T|
    while (не marker_centered) is (Да)
        |B|
        :Обновить current_time в blackboard;
        :BLOCK UpdateMarkerVisible в blackboard;
        :Обновить search_timed_out в blackboard;
        |T|
        if (marker_visible) then (Да)
            |B|
            :Обновить search_start_time в blackboard;
            :Обновить marker_centered в blackboard;
            |T|
            ' :res<vx,vy> = regulate_position_func();
            :BLOCK RegulatePositionFunc;
            ' :z_speed = regulate_height_func(PLD_SRCH_ALT, 0.0);
            :BLOCK RegulateHeightFunc;

            |B|
            :Обновить last_pid_time;
            :Установить скорости относительно СК дрона = vx, vy, vz, yaw(0.0);
            |T|
        else (Нет)
            if (search_timed_out) then (Да)
                :BLOCK Land;
            else (нет)
                :BLOCK Искать маркер;
            endif
        endif
    endwhile (Нет) 
}
stop


start

partition #LightBlue "PROGRAMM"{
    #LawnGreen :Запустить параллельно получение параметров - x_rad, y_rad, telem, last_time_marker_was_seen;
    
    |B|
    :Получить миссию и параметры миссии;
    :Установить начальное значение current_time;
    :Установить начальное значение marker_visible;
    |T|
    
    :BLOCK CheckLandedState;
    :BLOCK CheckRTLMission;
    :BLOCK PathFollowingOffboard;

    |B|
    :Установить начальное значение search_start_time = current_time;
    :Определить и добавить в blackboard search_timed_out = false;
    :Определить и добавить в blackboard marker_visible = true;
    |T|

    :BLOCK SearchMarker;

    :Создать объекты PID регуляторов позиции, высоты, поворота в blackboard;
    |B|
    :Создать last_pid_time = 0 и dr = sqrt(x_rad ** 2 + y_rad ** 2) в blackboard;
    |T|

    :BLOCK CenterAboveMarker;

    :BLOCK OrientationRegulation;

    :BLOCK CheckSearchTimeout;

    :BLOCK Landing;
}
stop


@enduml