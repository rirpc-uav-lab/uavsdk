@startuml

start
partition "BLOCK CheckLandedState"{
    if (landed_state == OnGround?) then (да)
        #pink:Вернуть FAILED;
        stop
    else (нет)
        #LimeGreen:Вернуть SUCCESS;
    endif
}

partition "BLOCK CheckRTLMission"{
    partition "BLOCK CheckMission"{
        :mission_not_empty = Проверить наличие точек в миссии в blackboard;
        if (mission_not_empty) then (Да)
            #LimeGreen:Вернуть SUCCESS;
        else (Нет)
            #pink:Вернуть FAILED;
        endif
    }
    :parameters_ready = Проверить наличие необходимых параметров;
    if (CheckMission == SUCCESS AND parameters_ready) then (Да)
        #LimeGreen:Вернуть SUCCESS;
    else (Нет)
        #pink:Вернуть FAILED;
        stop
    endif
}

partition "BLOCK PathFollowingOffboard"{
    :Выполнить полет;
}

:Определить и добавить в blackboard search_timed_out = false;
:Определить и добавить в blackboard marker_visible = true;

    ' :;
partition "BLOCK SearchMarker"{
    :Записать момент начала поиска;
    :Записать текущее время;
    :Создать флаги search_timed_out(false), marker_visible(false);
    :Перейти в Offboard;

    while (не search_timed_out) is (Да)
        if (не marker_visible) then (Да)
            partition "BLOCK SearchForMarker"{
                :Получить на вход параметры current_time, marker_visible, search_start_time, search_timed_out;
                partition "BLOCK UpdateCurrentTime"{
                    :ready = Проверить наличие current_time в blackboard;

                    if (ready) then (да)
                        :current_time = this->get_clock()->now().seconds() + this->get_clock()->now().nanoseconds() / double(1e9);
                        #LimeGreen:Вернуть SUCCESS;
                    else (нет)
                        #red :ИСКЛЮЧЕНИЕ;
                    endif
                }

                partition "BLOCK UpdateMarkerVisible"{
                    :ready = Проверить наличие marker_visible в blackboard;

                    if (ready) then (да)
                        :marker_visible = this->get_clock()->now().seconds() + this->get_clock()->now().nanoseconds() / double(1e9);
                        #LimeGreen:Вернуть SUCCESS;
                    else (нет)
                        #red :ИСКЛЮЧЕНИЕ;
                    endif
                }

                if (search_timed_out) then (Да)
                    partition "BLOCK Land"{
                        :Завершить режим Offboard;
                        :Перейти в режим Land;
                        :Сесть;
                        ' #pink #LimeGreen:Вернуть SUCCESS;
                        #Yellow :Вернуть SUCCESS;
                    }
                else (Нет)
                    #red :ИСКАТЬ МАРКЕР;
                endif
            }
        else (нет)
            :Обновить search_start_time в blackboard;
            break
        endif
    endwhile (Нет) 
    
    if (search_timed_out) then (да)
        :BLOCK Land;
        #pink:Вернуть FAILED;
    endif
}
    ' :;

:Создать объекты PID регуляторов позиции, высоты, поворота в blackboard;
:Создать last_pid_time = 0 и dr = sqrt(x_rad ** 2 + y_rad ** 2) в blackboard;

partition "BLOCK HelperFuncs"{
    :Определить regulate_position_func;
    :Определить regulate_height_func;
}

partition "CenterAboveMarker"{
    :Создать marker_centered = bool(x_rad > (PLD_ACC_RADIUS_DEG * M_PI / 180.0) or y_rad > (PLD_ACC_RADIUS_DEG * M_PI / 180.0)) в blackboard;
    while (не marker_centered) is (Да)
        :Обновить current_time в blackboard;
        :Обновить marker_visible в blackboard;
        :Обновить search_timed_out в blackboard;
        if (marker_visible) then (Да)
            :Обновить search_start_time в blackboard;
            :Обновить marker_centered в blackboard;
            ' :res<vx,vy> = regulate_position_func();
            partition "BLOCK RegulatePositionFunc"{
                :Получить на вход параметры dr, current_time, last_pid_time, pid из blackboard;
                :Обновить dr в blackboard;
                :float alpha = atan2(-y_rad, x_rad);

                :float x_speed = movement_radius * cos(alpha);
                :float y_speed = movement_radius * sin(alpha);

                :float vr = sqrt(x_speed * x_speed + y_speed * y_speed);
                if (vr > PLD_MAX_SPD)) then (Да)
                    :x_speed = PLD_MAX_SPD * cos(alpha);
                    :y_speed = PLD_MAX_SPD * sin(alpha);
                endif

                :Записать в blackboard параметры x_speed, y_speed, alpha;
                #LimeGreen:Вернуть SUCCESS;
            }
            ' :z_speed = regulate_height_func(PLD_SRCH_ALT, 0.0);
            partition "BLOCK RegulateHeightFunc"{
                :Получить на вход параметры current_time, last_pid_time, pid_z из blackboard;
                :Получить на вход аргументы goal_height, min_speed из blackboard;
            }
            :Обновить last_pid_time;
            :Установить скорости относительно СК дрона = vx, vy, vz;
        else (Нет)
            if (search_timed_out) then (Да)
                :BLOCK Land;
            else (нет)
                :BLOCK Искать маркер;
            endif
        endif
    endwhile (val) 
}

partition "BLOCK OrientationRegulation"{
    while (marker_visible AND ориентация не выровнена) is (Да)
        :Обновить search_start_time;
        :Обновить current_time;
        :Обновить marker_visible;
        :Обновить search_timed_out;
        :alpha = atan2(-y_rad, x_rad);
        :res<vx,vy> = regulate_position_func();
        :z_speed = regulate_height_func(PLD_SRCH_ALT, 0.0);

        if (ориентация не выровнена) then (Да)
            :yaw_speed = 180.0 / M_PI * pid_yaw.pid(alpha_rad, current_time - last_pid_time);
            :Установить скорости vx, vy, vz, yaw_speed;
        else (Нет)
            break
        endif
    endwhile (val) 
}

partition "BLOCK CheckSearchTimeout"{
    if (search_timed_out) then (Да)
        :BLOCK Land;
    endif
}

partition "BLOCK Landing"{
    while (current_landed_state != OnGround) is (Да)
        :Обновить current_time;
        :Обновить marker_visible;
        :Обновить search_timed_out;
        if (marker_visible) then (Да)
            :Обновить search_start_time;
            :alpha = atan2(-y_rad, x_rad);
            :res<vx,vy> = regulate_position_func();
            :z_speed = regulate_height_func(0.0, PLD_MIN_ALT_SPD);
            :yaw_speed = 180.0 / M_PI * pid_yaw.pid(alpha_rad, current_time - last_pid_time);
            :Установить скорости vx, vy, vz, yaw_speed;
        else (нет)
            :pid clear();
            if (search_timed_out) then (Да)
                :BLOCK Land;
            endif

            :Определить uav_above_land_guarantee_threshold;
            if (uav_above_land_guarantee_threshold) then (Да)
                :Определить uav_lower_than_search_altitude;
                if (uav_lower_than_search_altitude) then (Да)
                    :Лететь вверх;
                else (Нет)
                    :Лететь вниз;
                endif
                :Обновить last_pid_time;
            else (Нет)
                :BLOCK Land;
            endif
        endif
    endwhile (val) 
}

stop
' :Получить состояние посадки (landed_state);
' if (landed_state == OnGround?) then (да)
'     #pink:Вернуть FAILED;
'     stop
' else (нет)
'     :Проверить миссию;
'     if (land_geo_position доступен?) then (да)
'         :Добавить mission_items из land_geo_position;
'     else (нет)
'         :Добавить mission_items из home_position;
'     endif
'     :Загрузить миссию;
'     while (Загрузка миссии не удалась?)
'         if (Остановка запрошена?) then (да)
'             :Удержание;
'             :Вернуть RES_FAILED;
'             stop
'         else (нет)
'             :Повторить загрузку миссии;
'         endif
'     endwhile
'     :Запустить миссию;
'     while (Запуск миссии не удался?)
'         if (Остановка запрошена?) then (да)
'             :Удержание;
'             :Вернуть RES_FAILED;
'             stop
'         else (нет)
'             :Повторить запуск миссии;
'         endif
'     endwhile
'     :Ожидание завершения миссии;
'     while (Миссия не завершена?)
'         if (Остановка запрошена?) then (да)
'             :Удержание;
'             :Вернуть RES_FAILED;
'             stop
'         else (нет)
'             :Продолжить ожидание;
'         endif
'     endwhile
'     :Поиск маркера;
'     while (Маркер не найден и время не истекло?)
'         if (Остановка запрошена?) then (да)
'             :Удержание;
'             :Вернуть RES_FAILED;
'             stop
'         else (нет)
'             :Продолжить поиск;
'         endif
'     endwhile
'     if (Маркер найден?) then (да)
'         :Центрирование над маркером;
'         while (Не центрирован?)
'             if (Остановка запрошена?) then (да)
'                 :Удержание;
'                 :Вернуть RES_FAILED;
'                 stop
'             else (нет)
'                 :Регулировка положения;
'             endif
'         endwhile
'         :Регулировка ориентации;
'         while (Ориентация не корректна?)
'             if (Остановка запрошена?) then (да)
'                 :Удержание;
'                 :Вернуть RES_FAILED;
'                 stop
'             else (нет)
'                 :Регулировка ориентации;
'             endif
'         endwhile
'         :Посадка;
'         while (Не приземлился?)
'             if (Остановка запрошена?) then (да)
'                 :Удержание;
'                 :Вернуть RES_FAILED;
'                 stop
'             else (нет)
'                 :Продолжить посадку;
'             endif
'         endwhile
'         :Вернуть RES_SUCCESS;
'         stop
'     else (нет)
'         :Время поиска истекло;
'         :Посадка;
'         while (Не приземлился?)
'             if (Остановка запрошена?) then (да)
'                 :Удержание;
'                 :Вернуть RES_FAILED;
'                 stop
'             else (нет)
'                 :Продолжить посадку;
'             endif
'         endwhile
'         :Вернуть RES_SUCCESS;
'         stop
'     endif
' endif


@enduml